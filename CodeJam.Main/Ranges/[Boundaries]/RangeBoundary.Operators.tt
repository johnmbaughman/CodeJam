<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ include file="$(SolutionDir)Build\T4\Autogenerated.ttinclude" #>
<#@ include file="$(SolutionDir)CodeJam.Main\Arithmetic\Operators.ttinclude" #>
using System;
using System.Runtime.CompilerServices;

using static CodeJam.Targeting.MethodImplOptionsEx;

namespace CodeJam.Ranges
{
<#
	EmitForBoundary("From", ops);
	WriteLine();
	EmitForBoundary("To", ops);
#>
}<#+

	private void EmitForBoundary(string kind, IEnumerable<OpInfo> ops)
	{
#>
	/// <summary>The <#=kind#> boundary of the range.</summary>
	public partial struct RangeBoundary<#=kind#><T>
	{
		#region Operators
<#+
	foreach (var op in ops)
	{
		if (op.OpType != OpType.Comparison)
			continue;

		if (op.IsEqualityOp)
		{
			EmitEqualityOp(op, kind);
		}
		else
		{
			EmitComparisonOp(op, kind);
		}
	}
	FlushRegions();
	#>
		#endregion
	}
<#+
	}

	private void EmitEqualityOp(OpInfo op, string kind)
	{
		WriteRegionLine("Equality operators");
		var notOp = op.Type == ExpressionType.NotEqual? "!" : "";
#>
		/// <summary>Implements the operator <#=op.Sign#>.</summary>
		/// <param name="boundary1">The boundary1.</param>
		/// <param name="boundary2">The boundary2.</param>
		/// <returns><c>True</c>, if boundary1 <#=op.Sign#> boundary2.</returns>
		[MethodImpl(AggressiveInlining)]
		public static bool operator <#=op.Sign#>(RangeBoundary<#=kind#><T> boundary1, RangeBoundary<#=kind#><T> boundary2) =>
			<#=notOp#>boundary1.Equals(boundary2);
<#+
	}

	private void EmitComparisonOp(OpInfo op, string kind)
	{
		var escapedOp = EscapeXmlDocString(op.Sign);
		var invertedOp = op.Sign.StartsWith(">")
			? op.Sign.Replace('>', '<')
			: op.Sign.Replace('<', '>');
		var otherKind = kind == "From"? "To" : "From";
		WriteRegionLine("Comparison operators");
#>
		/// <summary>Implements the operator <#=escapedOp#>.</summary>
		/// <param name="boundary1">The boundary1.</param>
		/// <param name="boundary2">The boundary2.</param>
		/// <returns><c>True</c>, if boundary1 <#=escapedOp#> boundary2.</returns>
		[MethodImpl(AggressiveInlining)]
		public static bool operator <#=op.Sign#>(RangeBoundary<#=kind#><T> boundary1, RangeBoundary<#=kind#><T> boundary2) =>
			boundary1.CompareTo(boundary2) <#=op.Sign#> 0;

		/// <summary>Implements the operator <#=escapedOp#>.</summary>
		/// <param name="boundary1">The boundary1.</param>
		/// <param name="boundary2">The boundary2.</param>
		/// <returns><c>True</c>, if boundary1 <#=escapedOp#> boundary2.</returns>
		[MethodImpl(AggressiveInlining)]
		public static bool operator <#=op.Sign#>(RangeBoundary<#=kind#><T> boundary1, RangeBoundary<#=otherKind#><T> boundary2) =>
			boundary1.CompareTo(boundary2) <#=op.Sign#> 0;

		/// <summary>Implements the operator <#=escapedOp#>.</summary>
		/// <param name="boundary1">The boundary1.</param>
		/// <param name="boundary2">The value of the boundary2.</param>
		/// <returns><c>True</c>, if boundary1 <#=escapedOp#> boundary2.</returns>
		[MethodImpl(AggressiveInlining)]
		public static bool operator <#=op.Sign#>(RangeBoundary<#=kind#><T> boundary1, T? boundary2) =>
			boundary1.CompareTo(boundary2) <#=op.Sign#> 0;

		/// <summary>Implements the operator <#=escapedOp#>.</summary>
		/// <param name="boundary1">The value of the boundary1.</param>
		/// <param name="boundary2">The boundary2.</param>
		/// <returns><c>True</c>, if boundary1 <#=escapedOp#> boundary2.</returns>
		[MethodImpl(AggressiveInlining)]
		public static bool operator <#=op.Sign#>(T? boundary1, RangeBoundary<#=kind#><T> boundary2) =>
			boundary2.CompareTo(boundary1) <#=invertedOp#> 0;
<#+
	}
#>