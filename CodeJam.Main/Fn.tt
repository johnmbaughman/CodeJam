<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="$(SolutionDir)Build\T4\Autogenerated.ttinclude" #>
using System;

using JetBrains.Annotations;

namespace CodeJam
{
	/// <summary>
	/// Helper methods for <see cref="Func{TResult}"/> and <seealso cref="Action"/> delegates.
	/// </summary>
	public static partial class Fn
	{
<#
	WriteRegionLine("Action<...>");
	for (var i = 0; i < 8; i++)
	{
		if (i > 0)
			WriteLine("");
		EmitAction(i);
	}

	WriteRegionLine("Func<...>");
	for (var i = 0; i < 8; i++)
	{
		if (i > 0)
			WriteLine("");
		EmitFunc(i);
	}

	FlushRegions();
#>
	}
}<#+
	private void EmitAction(int argCount)
	{
		var typeList = argCount == 0
			? ""
			: "<" + List(argCount, n => "T" + n, ", ") + ">";
#>
		/// <summary>Helper for type inference from the lambda callback.</summary>
<#+
		for (var i = 1; i <= argCount; i++)
		{
#>
		/// <typeparam name="T<#= i #>">The type of argument #<#= i #>.</typeparam>
<#+
		}
#>
		/// <param name="action">The lambda callback.</param>
		/// <returns>The lambda callback passed.</returns>
		[Pure, System.Diagnostics.Contracts.Pure]
		public static Action<#= typeList #> Action<#= typeList #>(
			Action<#= typeList #> action)
		{
			Code.NotNull(action, nameof(action));
			return action;
		}
<#+
	}

	private void EmitFunc(int argCount)
	{
		var typeList = argCount == 0
			? "<TResult>"
			: "<" + List(argCount, n => "T" + n, ", ") + ", TResult" + ">";
#>
		/// <summary>Helper for type inference from the lambda callback.</summary>
<#+
		for (var i = 1; i <= argCount; i++)
		{
#>
		/// <typeparam name="T<#= i #>">The type of argument #<#= i #>.</typeparam>
<#+
		}
#>
		/// <typeparam name="TResult">The result type.</typeparam>
		/// <param name="func">The lambda callback.</param>
		/// <returns>The lambda callback passed.</returns>
		[Pure, System.Diagnostics.Contracts.Pure]
		public static Func<#= typeList #> Func<#= typeList #>(
			Func<#= typeList #> func)
		{
			Code.NotNull(func, nameof(func));
			return func;
		}
<#+
	}
#>