<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ include file="$(SolutionDir)Build\T4\Autogenerated.ttinclude" #>
using System;
using System.Linq.Expressions;

using JetBrains.Annotations;

namespace CodeJam.Expressions
{
	/// <summary>
	/// Provides helper methods for Action and Func delegates.
	/// </summary>
	public static class Expr
	{
<#
	WriteRegionLine("Action<...>");
	for (var i = 0; i < 8; i++)
	{
		if (i > 0)
			WriteLine("");
		EmitAction(i);
	}

	WriteRegionLine("Func<...>");
	for (var i = 0; i < 8; i++)
	{
		if (i > 0)
			WriteLine("");
		EmitFunc(i);
	}

	FlushRegions();
#>
	}
}<#+
	private void EmitAction(int argCount)
	{
		var typeList = argCount == 0
			? ""
			: "<" + List(argCount, n => "T" + n, ", ") + ">";
#>
		/// <summary>Helper for type inference from the lambda expression.</summary>
<#+
		for (var i = 1; i <= argCount; i++)
		{
#>
		/// <typeparam name="T<#= i #>">The type of argument #<#= i #>.</typeparam>
<#+
		}
#>
		/// <param name="actionExpression">The lambda expression.</param>
		/// <returns>The lambda expression passed.</returns>
		[Pure, System.Diagnostics.Contracts.Pure]
		public static Expression<Action<#= typeList #>> Action<#= typeList #>(
			Expression<Action<#= typeList #>> actionExpression)
		{
			Code.NotNull(actionExpression, nameof(actionExpression));
			return actionExpression;
		}
<#+
	}

	private void EmitFunc(int argCount)
	{
		var typeList = argCount == 0
			? "<TResult>"
			: "<" + List(argCount, n => "T" + n, ", ") + ", TResult" + ">";
#>
		/// <summary>Helper for type inference from the lambda expression.</summary>
<#+
		for (var i = 1; i <= argCount; i++)
		{
#>
		/// <typeparam name="T<#= i #>">The type of argument #<#= i #>.</typeparam>
<#+
		}
#>
		/// <typeparam name="TResult">The result type.</typeparam>
		/// <param name="funcExpression">The lambda expression.</param>
		/// <returns>The lambda expression passed.</returns>
		[Pure, System.Diagnostics.Contracts.Pure]
		public static Expression<Func<#= typeList #>> Func<#= typeList #>(
			Expression<Func<#= typeList #>> funcExpression)
		{
			Code.NotNull(funcExpression, nameof(funcExpression));
			return funcExpression;
		}
<#+
	}
#>
