<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ import namespace="System.Reflection" #>
<#@include file="$(SolutionDir)Build\T4\Autogenerated.ttinclude" #>
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;

using JetBrains.Annotations;

namespace CodeJam.Collections
{
	partial class DictionaryExtensions
	{
<#
	// ReSharper disable UnusedMember.Local
		var types =
			new[]
			{
				new { Name = "IDictionary", Conflict = false },
				new { Name = "IReadOnlyDictionary", Conflict = false },
				new { Name = "Dictionary", Conflict = false },
				new { Name = "ConcurrentDictionary", Conflict = false }
			};
		var self = GetType();
		const BindingFlags flags = BindingFlags.Instance | BindingFlags.NonPublic;
		var methodCount = self.GetMethods(flags).Count(m => m.Name.StartsWith("Header"));
		foreach (var type in types)
		{
		    var nullKeyConstraint = "where TKey: notnull";
#>
		#region <#= type.Name #><TKey, TValue> overloads
<#
			for (var i = 1; i <= methodCount; i++)
			{
				self.GetMethod("Header" + i, flags).Invoke(this, new object[] { type.Name, nullKeyConstraint });
				self.GetMethod((type.Conflict ? "Conflict" : "") + "Body" + i, flags).Invoke(this, new object[] { });
			}
#>
		#endregion

<#
		}
#>
	}
}

namespace CodeJam.Collections.Backported
{
	/// <summary>
	/// Extensions for <see cref="IDictionary{TKey,TValue}"/>
	/// that are not included in previous FW versions
	/// </summary>
	public static class DictionaryExtensions
	{
<#
		var backportedMethodCount = self.GetMethods(flags).Count(m => m.Name.StartsWith("BackportedHeader"));
		foreach (var type in types)
		{
		    var nullKeyConstraint = "where TKey: notnull";
#>
		#region <#= type.Name #><TKey, TValue> overloads
<#
			for (var i = 1; i <= backportedMethodCount; i++)
			{
				self.GetMethod("BackportedHeader" + i, flags).Invoke(this, new object[] { type.Name, nullKeyConstraint });
				self.GetMethod("Backported" + (type.Conflict ? "Conflict" : "") + "Body" + i, flags).Invoke(this, new object[] { });
			}
#>
		#endregion

<#
		}
#>
	}
}
<#+
	private void BackportedHeader1(string type, string nullKeyConstraint)
	{
#>
		/// <summary>
		/// Returns value associated with <paramref name="key"/>, or default(TValue) if key does not exists in
		/// <paramref name="dictionary"/>
		/// </summary>
		/// <typeparam name="TKey">The type of the key.</typeparam>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <param name="dictionary">The dictionary.</param>
		/// <param name="key">The key.</param>
		/// <returns>
		/// Value, associated with the <paramref name="key"/>, or default value if <paramref name="key"/> does not exists
		/// in <paramref name="dictionary"/>
		/// </returns>
		[Pure, System.Diagnostics.Contracts.Pure]
		[CollectionAccess(CollectionAccessType.Read)]
		public static TValue? GetValueOrDefault<TKey, TValue>(
			this <#= type #><TKey, TValue> dictionary,
			TKey key)
			<#= nullKeyConstraint #> =>
<#+
	}

	private void BackportedBody1()
	{
#>
			GetValueOrDefault(dictionary, key, default(TValue));

<#+
	}

	private void BackportedConflictBody1()
	{
#>
			GetValueOrDefault((IDictionary<TKey, TValue>)dictionary, key);

<#+
	}
#>

<#+
	private void BackportedHeader2(string type, string nullKeyConstraint)
	{
#>
		/// <summary>
		/// Returns value associated with <paramref name="key"/>, or <paramref name="defaultValue"/> if key does not exists
		/// in <paramref name="dictionary"/>
		/// </summary>
		/// <typeparam name="TKey">The type of the key.</typeparam>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <param name="dictionary">The dictionary.</param>
		/// <param name="key">The key.</param>
		/// <param name="defaultValue">Default value.</param>
		/// <returns>
		/// Value, associated with the <paramref name="key"/>, or <paramref name="defaultValue"/> if <paramref name="key"/>
		/// does not exists in <paramref name="dictionary"/>
		/// </returns>
		[Pure, System.Diagnostics.Contracts.Pure]
		[CollectionAccess(CollectionAccessType.Read)]
		public static TValue? GetValueOrDefault<TKey, TValue>(
			this <#= type #><TKey, TValue> dictionary,
			TKey key,
			TValue? defaultValue)
		<#= nullKeyConstraint #>
<#+
	}

	private void BackportedBody2()
	{
#>
		{
			Code.NotNull(dictionary, nameof(dictionary));

			TValue result;
			return
				dictionary.TryGetValue(key, out result)
					? result
					: defaultValue;
		}

<#+
	}

	private void BackportedConflictBody2()
	{
#>
		{
			GetValueOrDefault((IDictionary<TKey, TValue>)dictionary, key, defaultValue);
		}
<#+
	}
#>

<#+
	private void Header1(string type, string nullKeyConstraint)
	{
#>
		/// <summary>
		/// Returns value associated with <paramref name="key"/>, or default value if key does not exists
		/// in <paramref name="dictionary"/>
		/// </summary>
		/// <typeparam name="TKey">The type of the key.</typeparam>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <typeparam name="TResult">Result type.</typeparam>
		/// <param name="dictionary">The dictionary.</param>
		/// <param name="key">The key.</param>
		/// <param name="resultSelector">Function to select result.</param>
		/// <returns>
		/// Value, associated with the <paramref name="key"/>, or default value if <paramref name="key"/>
		/// does not exists in <paramref name="dictionary"/>
		/// </returns>
		[Pure, System.Diagnostics.Contracts.Pure]
		[CollectionAccess(CollectionAccessType.Read)]
		public static TResult? GetValueOrDefault<TKey, TValue, TResult>(
				this <#= type #><TKey, TValue> dictionary,
				TKey key,
				[InstantHandle] Func<TKey, TValue, TResult> resultSelector)
				<#= nullKeyConstraint #> =>
<#+
	}

	private void Body1()
	{
#>
			GetValueOrDefault(dictionary, key, resultSelector, default(TResult));

<#+
	}

	private void ConflictBody1()
	{
#>
			GetValueOrDefault((IDictionary<TKey, TValue>)dictionary, key, resultSelector, default(TResult));

<#+
	}
#>

<#+
	private void Header2(string type, string nullKeyConstraint)
	{
#>
		/// <summary>
		/// Returns value associated with <paramref name="key"/>, or <paramref name="defaultValue"/> if key does not exists
		/// in <paramref name="dictionary"/>
		/// </summary>
		/// <typeparam name="TKey">The type of the key.</typeparam>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <typeparam name="TResult">Result type.</typeparam>
		/// <param name="dictionary">The dictionary.</param>
		/// <param name="key">The key.</param>
		/// <param name="resultSelector">Function to select result.</param>
		/// <param name="defaultValue">Default value.</param>
		/// <returns>
		/// Value, associated with the <paramref name="key"/>, or <paramref name="defaultValue"/> if <paramref name="key"/>
		/// does not exists in <paramref name="dictionary"/>
		/// </returns>
		[Pure, System.Diagnostics.Contracts.Pure]
		[CollectionAccess(CollectionAccessType.Read)]
		public static TResult? GetValueOrDefault<TKey, TValue, TResult>(
			this <#= type #><TKey, TValue> dictionary,
			TKey key,
			[InstantHandle] Func<TKey, TValue, TResult> resultSelector,
			TResult? defaultValue)
			<#= nullKeyConstraint #>
<#+
	}

	private void Body2()
	{
#>
		{
			Code.NotNull(dictionary, nameof(dictionary));
			Code.NotNull(resultSelector, nameof(resultSelector));

			TValue result;
			return
				dictionary.TryGetValue(key, out result)
					? resultSelector(key, result)
					: defaultValue;
		}

<#+
	}

	private void ConflictBody2()
	{
#>
		{
			GetValueOrDefault((IDictionary<TKey, TValue>)dictionary, key, resultSelector, defaultValue);
		}

<#+
	}
#>

<#+
	private void Header3(string type, string nullKeyConstraint)
	{
#>
		/// <summary>
		/// Returns value associated with <paramref name="key"/>, or value returned by <paramref name="defaultValueFactory"/>
		/// if key does not exists in <paramref name="dictionary"/>
		/// </summary>
		/// <typeparam name="TKey">The type of the key.</typeparam>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <param name="dictionary">The dictionary.</param>
		/// <param name="key">The key.</param>
		/// <param name="defaultValueFactory">Function to return default value.</param>
		/// <returns>
		/// Value, associated with the <paramref name="key"/>, or value returned by <paramref name="defaultValueFactory"/>
		/// if <paramref name="key"/> does not exists in <paramref name="dictionary"/>
		/// </returns>
		[Pure, System.Diagnostics.Contracts.Pure]
		[CollectionAccess(CollectionAccessType.Read)]
		public static TValue GetValueOrDefault<TKey, TValue>(
			this <#= type #><TKey, TValue> dictionary,
			TKey key,
			[InstantHandle] Func<TKey, TValue> defaultValueFactory)
			<#= nullKeyConstraint #>
<#+
	}

	private void Body3()
	{
#>
		{
			Code.NotNull(dictionary, nameof(dictionary));
			Code.NotNull(defaultValueFactory, nameof(defaultValueFactory));

			TValue result;
			return
				dictionary.TryGetValue(key, out result)
					? result
					: defaultValueFactory(key);
		}

<#+
	}

	private void ConflictBody3()
	{
#>
		{
			GetValueOrDefault((IDictionary<TKey, TValue>)dictionary, key, defaultValueFactory);
		}

<#+
	}
#>

<#+
	private void Header4(string type, string nullKeyConstraint)
	{
#>
		/// <summary>
		/// Returns value associated with <paramref name="key"/>, or value returned by <paramref name="defaultValueFactory"/>
		/// if key does not exists in <paramref name="dictionary"/>
		/// </summary>
		/// <typeparam name="TKey">The type of the key.</typeparam>
		/// <typeparam name="TValue">The type of the value.</typeparam>
		/// <typeparam name="TResult">Result type.</typeparam>
		/// <param name="dictionary">The dictionary.</param>
		/// <param name="key">The key.</param>
		/// <param name="defaultValueFactory">Function to return default value.</param>
		/// <param name="resultSelector">Function to select result.</param>
		/// <returns>
		/// Value, associated with the <paramref name="key"/>, or value returned by <paramref name="defaultValueFactory"/>
		/// if <paramref name="key"/> does not exists in <paramref name="dictionary"/>
		/// </returns>
		[Pure, System.Diagnostics.Contracts.Pure]
		[CollectionAccess(CollectionAccessType.Read)]
		public static TResult GetValueOrDefault<TKey, TValue, TResult>(
			this <#= type #><TKey, TValue> dictionary,
			TKey key,
			[InstantHandle] Func<TKey, TValue, TResult> resultSelector,
			[InstantHandle] Func<TKey, TResult> defaultValueFactory)
			<#= nullKeyConstraint #>
<#+
	}

	private void Body4()
	{
#>
		{
			Code.NotNull(dictionary, nameof(dictionary));
			Code.NotNull(resultSelector, nameof(resultSelector));
			Code.NotNull(defaultValueFactory, nameof(defaultValueFactory));

			TValue result;
			return
				dictionary.TryGetValue(key, out result)
					? resultSelector(key, result)
					: defaultValueFactory(key);
		}
<#+
	}

	private void ConflictBody4()
	{
#>
		{
			GetValueOrDefault((IDictionary<TKey, TValue>)dictionary, key, resultSelector, defaultValueFactory);
		}
<#+
	}
#>